import numpy as np
from scipy.stats import mode
from sklearn.base import BaseEstimator

class HardVotingClassifier:

    def __init__(self, estimators: list) -> None:
        """Hard voting ensemble of estimators. The predictions made by
       independent estimators will be aggregated by predicting the most
       commonly predicted label among all estimators.

        Args:
            estimators (list): List of estimators whose predictions will be aggregated to produce the final prediction.
        """
        
        self.estimators = estimators
        self.name = 'Hard Voting Classifier'
        
    def fit(self, X: np.array, y: np.array) -> None:
        """Fit all estimators in the ensemble model.

        Args:
            X (np.array): Array of descriptors for all training samples.
            y (np.array): Array of labels for all training samples.
        """
        
        for estimator in self.estimators:
            estimator.fit(X, y)
            
    def predict(self, X: np.array) -> np.array:
        """Predict labels for all samples in the input array.

        Args:
            X (np.array): Array of descriptors for samples to be predicted.

        Returns:
            np.array: Array of predictions for all input samples.
        """
        
        y_preds = np.empty((X.shape[0], len(self.estimators)), dtype=int)
        
        for n, estimator in enumerate(self.estimators):
            
            y_preds[:, n] = estimator.predict(X)
            
        return mode(y_preds, axis=1)[0].reshape(-1,)
    
    def predict_proba(self, X: np.array) -> np.array:
        """Predict probabilities of labels for all samples in the input array.

        Args:
            X (np.array): Array of descriptors for samples to be predicted.

        Returns:
            np.array: Array of label probabilities for all input samples.
        """
        
        y_preds = np.empty((X.shape[0], len(self.estimators)), dtype=int)
        
        for n, estimator in enumerate(self.estimators):
            
            y_preds[:, n] = estimator.predict(X)
            
        return y_preds.mean(axis=1).reshape(-1,)

class SoftVotingClassifier:
    
    def __init__(self, estimators: list) -> None:
        """Soft voting ensemble of estimators. The predictions made by
       independent estimators will be aggregated by averaging the probabilities
       assigned by each estimator to each label, and predicting the label with 
       the highest average probability.

        Args:
            estimators (list): List of estimators whose predictions will be aggregated to produce the final prediction.
        """
        
        self.estimators = estimators
        self.name = 'Soft Voting Classifier'
        
    def fit(self, X: np.array, y: np.array) -> None:
        """Fit all estimators in the ensemble model.

        Args:
            X (np.array): Array of descriptors for all training samples.
            y (np.array): Array of labels for all training samples.
        """
        
        for estimator in self.estimators:
            estimator.fit(X, y)
            
    def predict(self, X: np.array) -> np.array:
        """Predict labels for all samples in the input array.

        Args:
            X (np.array): Array of descriptors for samples to be predicted.

        Returns:
            np.array: Array of predictions for all input samples.
        """
        
        y_preds = np.empty((X.shape[0], len(self.estimators)), dtype=float)
        
        for n, estimator in enumerate(self.estimators):
            
            y_preds[:, n] = estimator.predict_proba(X)[:, 1]

        return y_preds.mean(axis=1).round(0)
    
    def predict_proba(self, X: np.array) -> np.array:
        """Predict probabilities of labels for all samples in the input array.

        Args:
            X (np.array): Array of descriptors for samples to be predicted.

        Returns:
            np.array: Array of label probabilities for all input samples.
        """
        
        y_preds = np.empty((X.shape[0], len(self.estimators)), dtype=float)
        
        for n, estimator in enumerate(self.estimators):
            
            y_preds[:, n] = estimator.predict_proba(X)[:, 1]
        
        return np.vstack([1 - y_preds.mean(axis=1), y_preds.mean(axis=1)]).T

class StackedClassifier:
    
    def __init__(self, estimators: list, predictor: BaseEstimator) -> None:
        """Stacked classifier which trains an estimator that uses the predictions
       of another set of estimators as desriptors to featurize each sample.

        Args:
            estimators (list): List of estimators the will be used to generate features to train the stacked estimator.
            predictor (BaseEstimator): Estimator trained using the features generated by the list of estimators.
        """
        
        self.estimators = estimators
        self.predictor = predictor
        self.name = f'Stacked Classifier'
        
    def fit(self, X: np.array, y: np.array) -> None:
        """Fit all estimators in the ensemble model.

        Args:
            X (np.array): Array of descriptors for all training samples.
            y (np.array): Array of labels for all training samples.
        """
        
        X_train = np.empty((X.shape[0], len(self.estimators)))
        
        for n, estimator in enumerate(self.estimators):
            estimator.fit(X, y)
            X_train[:, n] = estimator.predict(X)
            
        self.predictor.fit(X_train, y)
            
    def predict(self, X: np.array) -> np.array:
        """Predict labels for all samples in the input array.

        Args:
            X (np.array): Array of descriptors for samples to be predicted.

        Returns:
            np.array: Array of predictions for all input samples.
        """
        
        X_pred = np.empty((X.shape[0], len(self.estimators)))
        
        for n, estimator in enumerate(self.estimators):
            X_pred[:, n] = estimator.predict(X)
        
        return self.predictor.predict(X_pred)
    
class SoftStackedClassifier:
    
    def __init__(self, estimators: list, predictor: BaseEstimator) -> None:
        """Soft stacked classifier which trains an estimator that uses the probabilities predicted
       by of another set of estimators as desriptors to featurize each sample.

        Args:
            estimators (list): List of estimators the will be used to generate features to train the stacked estimator.
            predictor (BaseEstimator): Estimator trained using the features generated by the list of estimators.
        """
        
        self.estimators = estimators
        self.predictor = predictor
        self.name = f'Stacked Soft Classifier'
        
    def fit(self, X: np.array, y: np.array) -> None:
        """Fit all estimators in the ensemble model.

        Args:
            X (np.array): Array of descriptors for all training samples.
            y (np.array): Array of labels for all training samples.
        """
        
        X_train = np.empty((X.shape[0], len(self.estimators)))
        
        for n, estimator in enumerate(self.estimators):
            estimator.fit(X, y)
            X_train[:, n] = estimator.predict_proba(X)[:, 1]
            
        self.predictor.fit(X_train, y)
            
    def predict(self, X: np.array) -> np.array:
        """Predict labels for all samples in the input array.

        Args:
            X (np.array): Array of descriptors for samples to be predicted.

        Returns:
            np.array: Array of predictions for all input samples.
        """
        
        X_pred = np.empty((X.shape[0], len(self.estimators)), dtype=float)
        
        for n, estimator in enumerate(self.estimators):
            X_pred[:, n] = estimator.predict_proba(X)[:, 1]
        
        return self.predictor.predict(X_pred)

    def predict_proba(self, X: np.array) -> np.array:
        """Predict probabilities of labels for all samples in the input array.

        Args:
            X (np.array): Array of descriptors for samples to be predicted.

        Returns:
            np.array: Array of label probabilities for all input samples.
        """
        
        X_pred = np.empty((X.shape[0], len(self.estimators)), dtype=float)
        
        for n, estimator in enumerate(self.estimators):
            X_pred[:, n] = estimator.predict_proba(X)[:, 1]

        return self.predictor.predict_proba(X_pred)
